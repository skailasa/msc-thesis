Practical implementations of the \gls{KIFMM} rely on the creation of efficient
surfaces used in the calculation of kernel matrices, as well as a stable method for
computing the inverse of these kernel matrices. The former problem naturally leads
to the implementation of caching code to cache, re-use, and scale operator matrices
as appropriate. Whereas the latter requires the implementation of a stable method to
solve the system of linear equations for each \gls{KIFMM} operator. As mentioned
in Chapter \ref{chpt:1_introduction}, Section \ref{sec:1_2_kifmm_overview}, \gls{PyExaFMM} uses
a pseudoinverse computed via an SVD to solve this linear system. This section
provides the implementation details used to address both of these issues.

\gls{PyExaFMM} uses cubic surfaces for all check and equivalent surfaces discretised
to the same degree, this follows the precedent set by the original authors \cite{Ying:2004:JCP}, and
allows for the application of simple quadrature rules to calculate the various
operator integrals such as those in equations (\ref{eq:1_2_m2m}), (\ref{eq:1_2_m2l})
and (\ref{eq:1_2_l2l}). In fact, as the number of quadrature points is generally
chosen to be relatively low \gls{PyExaFMM} just computes a direct computation to
compute the required integrals. Specifically, an order $p$ expansion results in,

\begin{equation}
    n_q =  6(p-1)^2 + 2
    \label{eq:2_2_quadrature_points}
\end{equation}

where $n_q$ is the number of quadrature points on a given surface. This equation can be
justified from the enforcement of the fact $p$ quadrature points are placed on the corners
of the cube, as well as being placed evenly along each edge of the cube. Similarly the
interior of each face of the cube is discretised to have quadrature points that form
a uniform Cartesian grid with the quadrature points on the edges and corners. Therefore,
by over-counting the nodes on the edge the 6 sides of the cube lead to $6p^2$ quadrature
points, however each corner point is overcounted three times, and the quadrature points
in the interior of a edge are overcounted twice. This leads to $6p^2 - 12(p-2) - 16$,
which is equivalent to (\ref{eq:2_2_quadrature_points}). Therefore even for an order $p=9$
expansion, which can be employed to compute potentials to 9 degrees of precision
\cite{Malhotra:2015:CCP}, there are just 386 quadrature points on a given check
or equivalent surface.

- Formation of surfaces
    - relationship between expansion order and number of surface points

- Re-use of surfaces, and translation
    - Comment on how particle distribution effects the operator computation

- Real values used for surface construction, from PVFMM
    - short comment on why these are found to be good

- Comment on current software choices
    - HDF5 vs pickle
    - python multiprocessing, task-level parallelism for M2L computation

Pseudoinverse
- Real values used for regularisation parameter in pseudoinverse
    - method used to get these in my work.
    - Real values used for the tolerance essentially derived from the above.

- Comment on PVFMM and ExaFMM-T approach which represents state of the art.
    - Brief discussion on the optimisations, specifically PVFMM,
    they pursue and how these could be implemented in PyExaFMM
    - Brief comment on potential stability improvements using Barnett+Betcke
    paper.
