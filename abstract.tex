\thispagestyle{plain}

\begin{center}
    \textbf{Declaration}
\end{center}
I, Srinath Kailasa, confirm that the work presented in this thesis is my own. Where information has been derived from other
sources, I confirm that this has been indicated in the thesis.

\begin{center}
    \textbf{Abstract}
\end{center}

The Fast Multipole Method (\gls{FMM}) is a numerical method to accelerate the solution
of the `n-body' problem, which appears in numerous contexts in science and engineering,
for example in solving for gravitational or electrostatic potentials. It does so by approximating
the Green's function of the
system with analytic infinite series expansions (the origin of the `multipole' in its name),
 and coalescing the effect of distinct distant sources together so as to
reduce the number of computations. The analytic expansions of the
original Fast Multipole Method depend on the Green's function of the system in
question (Helmholtz, Laplace etc.), and in practice a new implementations
must be written for a given system.

The Kernel-Independent Fast Multipole Method (\gls{KIFMM}),
first presented by Ying et al. \cite{Ying:2004:JCP}, is a similar approach that replaces
the analytic series expansions with a continuous distribution of so called
`equivalent density' supported at discrete points on a box enclosing a set of
particles. These equivalent densities are found by matching the potential they
generate to those generated by the original sources at another surface in the
far field. Usefully, this approach doesn't require multipole expansions of the
Green's functions of a system, and therefore can be programmed in an agnostic way,
hence the origin of it's name.

This thesis presents a Python implementation of
the KIFMM, with investigations made into both mathematical and computational
techniques for the acceleration of the algorithm. Python is chosen as it has emerged as a standard
for scientific and data intensive computing in recent years, with a huge increase
in usage and a well supported ecosystem of libraries and tools available for
accelerating numerical codes. The wider context of this thesis
is an ongoing collaboration with the ExaFMM Project \cite{exafmm} to produce a Pythonic
implementation of the KIFMM that sacrifices as little performance as possible.
This thesis presents a systematic performance analysis
of a naive implementation of the KIFMM algorithm, before proceeding to examine and implement
acceleration techniques. The speed and accuracy of the implementation is tested
for some simple Green's functions, and it concludes with a discussion on future avenues
for investigation.